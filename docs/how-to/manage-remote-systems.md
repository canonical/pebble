# How to use Pebble to manage remote systems

Managing a cluster of servers remotely is no mean feat. It is time-consuming because servers need regular software updates, configuration changes, file transfers, and command executions. It also presents security challenges because remote access requires opening ports, which increases the potential attack surface.

## Why use Pebble?

Pebble provides commands and an HTTP API to run commands and manage files and directories in remote systems. If we run Pebble in a remote system, for example in a separate container, we can use Pebble to coordinate with the remote system without opening a new port.

While it's possible to manually run commands on remote servers and transfer files from/to remote servers, this isn't the most efficient or secure approach. Even a configuration management tool such as Ansible requires an extra port to be opened for Secure Shell (SSH), which not only increases the operational overhead of managing public/private keys but also the potential attack surface.

Remember March 29, 2024 which seemed to be another normal Friday? A developer shocked the world by revealing an XZ Utils (data-compression utilities) backdoor which could potentially enable unauthorized access via SSH and remote code execution (read the full story [here](https://en.wikipedia.org/wiki/XZ_Utils_backdoor)).

## Run commands in remote systems

One common task in system administration is updating and installing packages on remote servers. With Pebble, we can use the `pebble exec` command to achieve this.

For example, if Pebble is running as user with root privileges, we can use this command to update and install packages in remote systems:

```{terminal}
:input: pebble exec apt update
Hit:1 http://ports.ubuntu.com/ubuntu-ports noble InRelease
Get:2 http://ports.ubuntu.com/ubuntu-ports noble-updates InRelease [126 kB]
Get:3 http://ports.ubuntu.com/ubuntu-ports noble-backports InRelease [126 kB]
...
Fetched 3121 kB in 38s (81.5 kB/s)
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
41 packages can be upgraded. Run 'apt list --upgradable' to see them.
```

To install a package, run:

```bash
pebble exec apt install cowsay
```

To confirm the package is successfully installed in the remote system, run:

```{terminal}
:input: pebble exec cowsay moo
 _____
< moo >
 -----
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
```

For more information on the Pebble `exec` command, see {ref}`reference_pebble_exec_command`.

## Manage files in remote systems

Another common task in remote systems is configuration management. For example, updating configuration files, pushing files to servers, pulling files generated by running services, and so on.

With Pebble, this can be done easily. For example, if we want to install Nginx, create our own website, and serve it on a newly created virtual host, we can first install Nginx:

```bash
pebble exec apt install nginx
```

Then create our website _locally_:

```bash
echo "Hello, Pebble!" > /tmp/index.html
```

Create a directory in the remote system:

```bash
pebble mkdir -p /var/www/pebble
```

Push our local website file to the remote system:

```bash
pebble push /tmp/index.html /var/www/pebble/index.html
```

Create a virtual host configuration _locally_:

```
cat <<EOF > /tmp/pebble
server {
       listen 81;
       listen [::]:81;

       server_name example.ubuntu.com;

       root /var/www/pebble;
       index index.html;

       location / {
               try_files \$uri \$uri/ =404;
       }
}
EOF
```

Push the file to the remote system:

```bash
pebble push /tmp/pebble /etc/nginx/sites-enabled/pebble
```

Activate the newly added virtual host in the remote system by restarting Nginx:

```bash
pebble exec service nginx restart
```

Finally, we can test the final result:

```{terminal}
:input: curl localhost:81
Hello, Pebble!
```

For more information about related Pebble commands, see:

- {ref}`reference_pebble_ls_command`
- {ref}`reference_pebble_mkdir_command`
- {ref}`reference_pebble_rm_command`
- {ref}`reference_pebble_push_command`
- {ref}`reference_pebble_pull_command`

## Use the API

In the previous sections, we used Pebble commands to run commands and manage files. When automating these tasks, we can use the HTTP API that Pebble provides.

For example, to push a file to the remote system, we can POST to the `/v1/files` endpoint:

```bash
curl --unix-socket $PEBBLE/.pebble.socket -XPOST localhost:4000/v1/files -H "Content-Type: multipart/form-data" -F request='{"action": "write", "files": [{"path": "/var/www/pebble/index.html", "make-dirs": true, "permissions": "644"}]}' -F 'files=@/tmp/index.html;type=application/octet-stream;filename=/var/www/pebble/index.html'
```

## See more

In this guide, we used Pebble commands and curl to access the API. We can also access the API using Go and Python. For more information, see [How to use the Pebble API to manage services](/how-to/use-the-pebble-api).

For more information on the API, read the [API spec](/reference/api).
